Explanation:
Dependencies: We use ethers which bundles core types, signers, etc.
Private Key: Defined as a hex string.
Message Hash: We define a H256 (ethers' type for a 32-byte hash). Crucially, you need to replace the example hash with the actual hash you intend to sign.
Create Wallet: LocalWallet::from_str(private_key_hex) directly parses the hex key (handling the "0x" prefix) and creates the signer object.
Sign Hash: wallet.sign_hash(message_hash) performs the ECDSA signature on the provided hash.
Extract v, r, s: The resulting Signature struct directly contains r, s, and v.
r and s are U256 values.
v (as signature.v) in ethers-rs for hashes signed this way is usually the value 27 or 28.
We calculate the v_parity (0 or 1) which is often what's meant by "v" in lower-level contexts. v_parity = signature.v % 2 works reliably for values 27 and 28.
Output: Prints the derived components.
Verification: Includes a step to verify the signature against the original hash and the wallet's public address.
This approach uses a well-maintained library (ethers-rs) and avoids the complexities of feature flags you were encountering previously. Just make sure to replace the placeholder private key and message hash with your actual data.